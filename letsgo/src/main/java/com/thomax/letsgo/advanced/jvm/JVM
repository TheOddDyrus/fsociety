1.内存模型 {
    1.1 虚拟机栈 {
        每个线程有一个私有的栈，随着线程的创建而创建。栈的大小可以固定也可以动态扩展。
        当栈调用深度大于JVM所允许的范围，会抛出StackOverflow的错误。
        *栈帧 {
            每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息
        }
    }
    1.2 本地方法栈 {
        这部分主要与虚拟机用到的native方法相关，一般情况下，Java应用程序员并不需要关心这部分的内容。
    }
    1.3 PC寄存器 {
        也叫程序计数器，JVM支持多个线程同时运行，每个线程都有自己的程序计数器。
        倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；
        倘若执行的是native 方法，则PC寄存器中为空。
    }
    1.4 堆 {
        堆内存是JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。
        所有的对象和数组都在堆上进行分配，这部分空间可通过 GC 进行回收，当申请不到空间时会抛出 OutOfMemoryError
    }
    1.5 方法区 {
        方法区也是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。
        方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”
    }
}


2.HotSpot虚拟机 {
    2.1 对象结构 {
        对象头（Header） {
            markword {
                用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，
                这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“MarkWord”。
            }
            klass {
                对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
            }
            数组长度（只有数组对象有） {
                如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度。
            }
        }
        实例数据（Instance Data） {
            实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。
        }
        和对齐填充（Padding） {
            它不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。
            由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。
            而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。
        }
    }
    2.2 对象大小计算 {
        · 在32位系统下，存放Class指针的空间大小是4字节，MarkWord是4字节，对象头为8字节。
        · 在64位系统下，存放Class指针的空间大小是8字节，MarkWord是8字节，对象头为16字节。
        · 64位开启指针压缩的情况下，存放Class指针的空间大小是4字节，MarkWord是8字节，对象头为12字节。
          数组长度4字节+数组对象头8字节(对象引用4字节（未开启指针压缩的64位为8字节）+数组markword为4字节（64位未开启指针压缩的为8字节）)+对齐4=16字节。
        · 静态属性不算在对象大小内
    }
    2.3 OOP-Klass对象模型 {
        #define {
            volatile markOop _mark;  //标识运行时数据
            union _metadata {
                Klass*      _klass;
                narrowKlass _compressed_klass;
            } _metadata;  //klass指针
        }
        · 类被加载到内存时，就被封装成了klass，klass包含类的元数据信息，像类的方法、常量池这些信息都是存在klass里的，你可以认为它是java里面的java.lang.Class对象，记录了类的全部信息；
        · OOP（Ordinary Object Pointer）指的是普通对象指针，它包含MarkWord 和元数据指针，MarkWord用来存储当前指针指向的对象运行时的一些状态数据；
          元数据指针则指向klass,用来告诉你当前指针指向的对象是什么类型，也就是使用哪个类来创建出来的；
        # 原因：那么为何要设计这样一个一分为二的对象模型呢？这是因为HotSopt JVM的设计者不想让每个对象中都含有一个vtable（虚函数表），所以就把对象模型拆成klass和oop，
               其中oop中不含有任何虚函数，而klass就含有虚函数表，可以进行method dispatch。
    }
}


3.内存回收策略 {
    3.1 按基本回收策略 {
        引用计数（Reference Counting） {
            比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。
            垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。
            垃圾回收的起点是一些根对象（java栈, 静态变量, 寄存器...）。而最简单的Java栈就是Java程序执行的main函数。
        }
        标记-清除（Mark-Sweep） {
            此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。
            此算法需要暂停整个应用，同时，会产生内存碎片。
        }
        复制（Copying） {
            此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。
            次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。
            当然，此算法的缺点也是很明显的，就是需要两倍内存空间。
        }
        标记-整理（Mark-Compact） {
            此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，
            第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。
            此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。
        }
    }
    3.2 按分区对待的方式 {
        增量收集（Incremental Collecting） {
            实时垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。
        }
        分代收集（Generational Collecting） {
            基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、永久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。
            现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的：{
                *为什么要分代 {
                    不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
                    在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。
                    但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。
                    试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，
                    同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。
                    因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。
                }
                *如何分代 {
                    年轻代（Young） {
                        所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。一般年轻代分三个区：1个Eden区，2个Survivor区(比例是8:1:1)。
                        大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，
                        当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”，即年轻代中对象经历过2次幸存过后会进入年老代。
                        需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，
                        而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），
                        这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。
                    }
                    年老代（Tenured） {
                        在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
                    }
                    永久代（Permanent） {
                        用于存放静态文件，如今Java类、方法等。永久代对垃圾回收没有显著影响，
                        但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。
                        永久代大小通过-XX:MaxPermSize=进行设置。
                        （JDK1.8中永久带被移除，由元数据区替换，元数据区不属于JVM内存模型，它属于系统内存）
                    }
                }
            }
        }
    }
    3.3 按系统线程 {
        串行收集 {
            串行收集使用单线程处理所有垃圾回收工作, 因为无需多线程交互，实现容易，而且效率比较高。
            但是，其局限性也比较明显，即无法使用多处理器的优势，所以此收集适合单处理器机器。
            当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。
        }
        并行收集 {
            并行收集使用多线程处理垃圾回收工作，因而速度快，效率高。而且理论上CPU数目越多，越能体现出并行收集器的优势。
        }
        并发收集 {
            相对于串行收集和并行收集而言，前面两个在进行垃圾回收工作时，需要暂停整个运行环境，只有垃圾回收程序在运行，而且暂停时间会因为堆越大而越长。
            使用并发收集可以解决同时存在的对象创建和对象回收问题。
        }
    }
}


4.触发垃圾回收 {
    4.1 Scavenge GC {
        一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。
        然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。
        因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。
        因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。
    }
    4.2 Full GC {
        对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。
        在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：{
            · 年老代（Tenured）被写满
            · 永久代（Perm）被写满
            · System.gc()被显示调用
            · 上一次GC之后Heap的各域分配策略动态变化
        }
    }
}


5.JVM启动命令 {
    -XX:MaxPermSize=  设置永久带大小
    -XX:+UseSerialGC  打开串行收集器
    -XX:+UseParallelGC  打开并行收集器
    -XX:+UseParallelOldGC  打开并行收集器（增强到可以对年老代进行并行收集；如果年老代不使用并发收集的话，默认是使用单线程进行垃圾回收，因此会制约扩展能力）
        -XX:ParallelGCThreads=  设置并行垃圾回收的线程数（此值可以设置与机器处理器数量相等）
        -XX:MaxGCPauseMillis=  设置垃圾回收时的最长暂停时间（如果指定了此值的话，堆大小和垃圾回收相关参数会进行调整以达到指定值。设定此值可能会减少应用的吞吐量）
        -XX:GCTimeRatio=<N>  设置垃圾回收的吞吐量（吞吐量为垃圾回收时间与非垃圾回收时间的比值，公式为1/(1+N)，例如当N=19时，表示5%的时间用于垃圾回收。默认情况为N=99，即1%的时间用于垃圾回收）
    -XX:+UseConcMarkSweepGC  打开并发收集器
        -XX:CMSInitiatingOccupancyFraction=  指定还有多少剩余堆时开始执行并发收集（因为在应用运行的同时进行垃圾回收，所以有些垃圾可能在垃圾回收进行完成时产生，
                                                                                这样就造成了“Floating Garbage”，这些垃圾需要在下次垃圾回收周期时才能回收掉。
                                                                                所以，并发收集器一般需要20%的预留空间用于这些浮动垃圾，如果没有预留足够的内存空间供程序使用，
                                                                                会出现“Concurrent Mode Failure”此时整个应用将会暂停，进行垃圾回收）
    -Xmx3550m： 设置JVM最大堆内存为3550M。
    -Xms3550m： 设置JVM初始堆内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
    -Xmn2g： 设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 永久代大小。永久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。
             此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
    -Xss128k： 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。
               在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。
    -XX:NewSize=n： 设置年轻代大小
    -XX:NewRatio=4： 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去永久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5
    -XX:SurvivorRatio=4： 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
    -XX:MaxPermSize=16m： 设置永久代大小为16m
    -XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。
                                 如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。
    ++还有一些命令行参数用于打印信息，供调试使用，此处忽略。。。
}


6.经典配置 {
    6.1 科学技术和后台处理 {
        java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20
        java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC
        java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100
        java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy
    }
    6.2 应用服务器、电信领域 {
        java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC
        java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection
    }
	6.3 普通项目VM option {
		-Xms128m -Xmx750m -XX:MaxPermSize=512m -Dfile.encoding=utf-8
	}
	6.4 性能测试时的操作 {
	    1.调用JVM时指定 -verbose:gc 来判断是否执行了垃圾回收的操作
	    2.确保垃圾回收的操作在测试期间执行了多次；一般使用这种，可以充分反映运行时内存分配和垃圾回收等开销，更接近生产环境
	}
}


7.JDK1.8的元空间 {
    在 JDK 1.8 中， HotSpot 已经没有“PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间）的东西。
    JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除 {
        譬如符号引用(Symbols)转移到了native heap；
        字面量(interned strings)转移到了java heap；
        类的静态变量(class statics)转移到了java heap
    }
    -XX:MetaspaceSize  初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；
                       如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
　　-XX:MaxMetaspaceSize  最大空间，默认是没有限制的。除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：
　　-XX:MinMetaspaceFreeRatio  在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
　　-XX:MaxMetaspaceFreeRatio  在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集
}


8.Java解释器执行模型（不考虑异常处理）{
    do {
        自动计算PC寄存器的值加1；
        根据PC寄存器的指示位置，从字节码流中取出操作码；
        if (字节码存在操作数) 从字节码流中取出操作数；
        执行操作码所定义的操作
    } while (字节码流长度 > 0)
}



