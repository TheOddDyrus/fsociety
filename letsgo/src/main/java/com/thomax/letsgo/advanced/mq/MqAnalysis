RocketMQ汇总 {
    RocketMQ由哪些角色组成 {
        生产者（Producer）：负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。
        消费者（Consumer）：负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。
        消息服务器（Broker）：是消息存储中心，主要作用是接收来自 Producer 的消息并存储， Consumer 从这里取得消息。
        名称服务器（NameServer）：用来保存 Broker 相关 Topic 等元信息并给 Producer ，提供 Consumer 查找 Broker 信息。
    }
    RocketMQ执行流程 {
        1、启动 Namesrv，Namesrv起 来后监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心。
        2、Broker 启动，跟所有的 Namesrv 保持长连接，定时发送心跳包。
        3、收发消息前，先创建 Topic 。创建 Topic 时，需要指定该 Topic 要存储在 哪些 Broker上。也可以在发送消息时自动创建Topic。
        4、Producer 发送消息。
        5、Consumer 消费消息。
    }
}


**************Kafka、RabbitMQ、RocketMQ、ActiveMQ汇总：
开发语言 {
    Kafka：Scala
    RabbitMQ：Erlang
    RocketMQ：Java
    ActiveMQ：Java
}

支持协议 {
    Kafka：基于TCP自定义的一套
    RabbitMQ：AMQP
    RocketMQ：自定义的对象MessageExt
    ActiveMQ：OpenWire、STOMP、REST、XMPP、AMQP
}

消息存储 {
    Kafka {
        内存、磁盘、数据库。支持大量堆积。kafka的最小存储单元是分区，一个topic包含多个分区，kafka创建主题时，这些分区会被分配在多个服务器上，通常一个broker一台服务器。
        分区首领会均匀地分布在不同的服务器上，分区副本也会均匀的分布在不同的服务器上，确保负载均衡和高可用性，当新的broker加入集群的时候，部分副本会被移动到新的broker上。
        根据配置文件中的目录清单，kafka会把新的分区分配给目录清单里分区数最少的目录。 默认情况下，分区器使用轮询算法把消息均衡地分布在同一个主题的不同分区中，对于发送时指定了key的情况，
        会根据key的hashcode取模后的值存到对应的分区中。
    }
    RabbitMQ {
        内存、磁盘。支持少量堆积。**rabbitmq的消息分为持久化的消息和非持久化消息，不管是持久化的消息还是非持久化的消息都可以写入到磁盘。持久化的消息在到达队列时就写入到磁盘，
        并且如果可以，持久化的消息也会在内存中保存一份备份，这样可以提高一定的性能，当内存吃紧的时候会从内存中清除。非持久化的消息一般只存在于内存中，在内存吃紧的时候会被换入到磁盘中，
        以节省内存。引入镜像队列机制，可将重要队列“复制”到集群中的其他broker上，保证这些队列的消息不会丢失。配置镜像的队列，都包含一个主节点master和多个从节点slave,如果master失效，
        加入时间最长的slave会被提升为新的master，除发送消息外的所有动作都向master发送，然后由master将命令执行结果广播给各个slave，rabbitmq会让master均匀地分布在不同的服务器上，
        而同一个队列的slave也会均匀地分布在不同的服务器上，保证负载均衡和高可用性。
    }
    RocketMQ {
        磁盘。支持大量堆积 commitLog文件存放实际的消息数据，每个commitLog上限是1G，满了之后会自动新建一个commitLog文件保存数据。ConsumeQueue队列只存放offset、size、tagcode，非常小，
        分布在多个broker上。ConsumeQueue相当于CommitLog的索引文件，消费者消费时会从consumeQueue中查找消息在commitLog中的offset，再去commitLog中查找元数据。ConsumeQueue存储格式的特性，
        保证了写过程的顺序写盘（写CommitLog文件），大量数据IO都在顺序写同一个commitLog，满1G了再写新的。加上rocketmq是累计4K才强制从PageCache中刷到磁盘（缓存），所以高并发写性能突出。
    }
    ActiveMQ {
        内存、磁盘、数据库。支持少量堆积
    }
}

消息事务 {
    Kafka：支持
    RabbitMQ：支持。客户端将信道设置为事务模式，只有当消息被rabbitMq接收，事务才能提交成功，否则在捕获异常后进行回滚。使用事务会使得性能有所下降
    RocketMQ：支持。MQ事务建立在持久化基础上，消息持久化成功后返回一个ACK，成为半消息。后续消费者消费这个消息将返回commit/rollback，MQServer对没有返回commit/rollback的进行回查
    ActiveMQ：支持
}

可用性 {
    Kafka：非常高（分布式）
    RabbitMQ：高（主从）
    RocketMQ：非常高（分布式）
    ActiveMQ：高（主从）
}

消息重复 {
    Kafka：支持at least once、at most once
    RabbitMQ：支持at least once、at most once
    RocketMQ：支持at least once
    ActiveMQ：支持at least once
}

吞吐量TPS {
    Kafka：(十万级, 17万 -> 极大) Kafka按批次发送消息和消费消息。发送端将多个小消息合并，批量发向Broker，消费端每次取出一个批次的消息批量处理
    RabbitMQ：(万级别,5万 -> 比较大)
    RocketMQ：(十万级别 -> 大) rocketMQ接收端可以批量消费消息，可以配置每次消费的消息数，但是发送端不是批量发送
    ActiveMQ：(万级别 -> 比较大)
}

顺序消息 {
    Kafka：设置生产者的max.in.flight.requests.per.connection为1, 可以保证消息是按照发送顺序写入服务器的,即使发生了重试, Kafka保证同一个分区的消息是有序的,
           但是这种分两种情况: key为null, 消息逐个写入不同的主机分区中, 但是对于每个分区依然是有序的. key不为null, 消息被写入同一个分区,这个分区的消息都是有序的
    RabbitMQ：不支持
    RocketMQ：不支持
    ActiveMQ：不支持
}

消息确认 {
    Kafka：支持
    RabbitMQ：支持
    RocketMQ：支持
    ActiveMQ：支持
}

消息回溯 {
    Kafka：支持指定分区offset位置的回溯
    RabbitMQ：不支持
    RocketMQ：支持指定时间点的回溯
    ActiveMQ：不支持
}

负载均衡 {
    Kafka（支持负载均衡）{
        1.一个broker通常就是一台服务器节点. 对于同一个Topic的不同分区, Kafka会尽力将这些分区分布刀不同的Broker服务器上, zookeeper保存了broker, 主题和分区的元数据信息.
          分区首领会处理来自客户端的生产请求, Kafka分区首领会被分配到不同的zookeeper服务器上, 让不同的broker服务器共同分担任务.每一个broker都缓存元数据信息,
          客户端可以从任意一个broker获取元数据信息并缓存起来, 根据元数据信息知道要往哪里发送请求.
        2.Kafka的消费者组订阅同一个topic, 会尽可能地使得每一个消费者分配到相同数量的分区, 分摊负载.
        3.当消费者组订阅了同一个topic， 还会促发再均衡， 为每一个消费者重新分配分区， 分摊负责。Kafka的负载均衡大部分是自动完成的， 分区的创建也是Kafka完成的， 隐藏了许多细节，
          避免了繁琐的配置和人为疏忽造成的负载问题。
        4.发送端由topic和key来决定消息发送到那个分区，如果key为null，那么会使用轮询算法将消息负载发送到同一个topic的不同分区中。 如果key不为null，那么会根据key的hashcode取模计算要发往的分区。
    }
    RabbitMQ（对负载均衡的支持不好）{
        1.消息被投递到那个队列是由交换机和key决定的， 交换器，路由键， 队列都需要手动创建，rabbitMQ客户端发送消息要和broker建立连接， 需要事先知道broker有那些交换器，
          有那些队列。通常要声明发送的目标队列， 如果没有目标队列， 会在broker上创建一个队列，如果有，就什么都不处理， 接着往这个队列发送消息。假设大部分繁琐的任务都在同一个broker上，
          那这个broker的负载会过大。（可以在上线前预先创建队列，无需声明要发送的队列，但是发送时不会尝试去创建队列，可能出现找不到队列的问题, rabbitmq的备份交换器会把找不到队列的消息
          保存到一个专门的队列中,以便以后查询用）使用镜像队列机制建立rabbitmq集群可以解决这个问题, 形成master-slave的架构, master节点会均匀分布在不同的服务器上, 让每一台服务器分摊负载.
          slave节点只是负责转发, 在master失效时会选择加入时间最长的slaver成为master当新节点加入镜像队列的时候, 队列中的消息不会同步到新的slaver中,除非调用同步命令, 但是调用命令后,
          队列会阻塞, 不能在生产环境中调用同步命令
        2.当rabbitmq队列拥有多个消费者的时候，队列收到的消息将以轮询的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者，不会重复。这种方式非常适合扩展，而且是专门为并发程序设计的。
          如果某些消费者的任务比较繁重，那么可以设置basicQos限制信道上消费者能保持的最大未确认消息的数量，在达到上限时，rabbitmq不再向这个消费者发送任何消息。
        3.对于rabbitmq而言，客户端与集群建立的TCP连接不是与集群中所有的节点建立连接，而是挑选其中一个节点建立连接。但是rabbitmq集群可以借助HAProxy、LVS技术，或者在客户端使用算法实现负载均衡，
          引入负载均衡之后，各个客户端的连接可以分摊到集群的各个节点之中。
    }
    RocketMQ（支持负载均衡）{
        1.nameserver与每个集群成员保持心跳，保存着Topic-Broker路由信息，同一个topic的队列会分布在不同的服务器上。
        2.发送消息通过轮询队列的方式发送，每个队列接收平均的消息量。发送消息指定topic、tags、keys，无法指定投递到哪个队列（没有意义，集群消费和广播消费跟消息存放在哪个队列没有关系）。
          tags选填，类似于Gmail为每封邮件设置的标签，方便服务器过滤使用。目前只支 持每个消息设置一个tag，所以也可以类比为 Notify 的 MessageType 概念。
          keys选填，代表这条消息的业务关键词，服务器会根据keys创建哈希索引，设置后， 可以在Console系统根据Topic、Keys来查询消息，由于是哈希索引，请尽可能保证key唯一，例如订单号，商品Id等。
        3.rocketmq的负载均衡策略规定：Consumer数量应该小于等于Queue数量，如果Consumer超过Queue数量，那么多余的Consumer将不能消费消息。这一点和kafka是一致的，
          rocketmq会尽可能地为每一个Consumer分配相同数量的队列，分摊负载。
    }
    ActiveMQ（支持负载均衡）{
        可以基于zookeeper实现负载均衡
    }
}

集群方式 {
    Kafka（天然的Leader-Slave无状态集群, 每台服务既是Master也是Slave）{
       分区首领均匀地分布在不同的Kafka服务器上, 分区副本业均匀地分布在不同的Kafka服务器上, 所以每台kafka服务既含分区首领, 同时又含有分区副本, 每一台kafka服务器是某一台kafka服务器的Slave,
       同时也是某一台kafka服务器的leader, kafka的集群依赖与zookeeper, zookeeper支持热拓展, 所有的broker, 消费者, 分区都可以动态移除, 而无需关闭服务, 与不依赖zookeeper集群的mq相比, 这是最大的优势.
    }
    RabbitMQ（支持简单集群，"复制"模式，对高级集群模式支持不好）{
        rabbitmq的每一个节点，不管是单一节点系统或者是集群中的一部分，要么是内存节点，要么是磁盘节点，集群中至少要有一个是磁盘节点。
        在rabbitmq集群中创建队列，集群只会在单个节点创建队列进程和完整的队列信息（元数据、状态、内容），而不是在所有节点上创建。没有拓展性可言
        引入镜像队列，可以避免单点故障，确保服务的可用性，但是需要人为地为某些重要的队列配置镜像。
    }
    RocketMQ（常用多对Master-Slave模式，开源版本需手动切换Slave变成Master）{
        Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，
        Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与Name Server集群中的所有节点建立长连接，
        定时注册Topic信息到所有Name Server。Producer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，
        且定时向Master发送心跳。Producer完全无状态，可集群部署。Consumer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、
        Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。客户端先找到NameServer, 然后通过NameServer再找到 Broker。
        一个topic有多个队列，这些队列会均匀地分布在不同的broker服务器上。rocketmq队列的概念和kafka的分区概念是基本一致的，kafka同一个topic的分区尽可能地分布在不同的broker上，
        分区副本也会分布在不同的broker上。rocketmq集群的slave会从master拉取数据备份，master分布在不同的broker上。
    }
    ActiveMQ（支持简单Master-Slave集群模式）{
        对高级集群模式支持不好
    }
}

订阅形式和消息分发 {
    Kafka（基于topic以及按照topic进行正则匹配的发布订阅模式）{
        发送 {
            发送端由topic和key来决定消息将发往那个分区,如果key为null, 那么会使用轮询算法将消息均衡地发送到同一个topic的不同分区中. 如果key不是null, 那么会将key的hashcode取模计算出要发往的分区.
        }
        接收 {
            1.consumer向群组协调器broker发送心跳来维持他们和群组的从属关系以及他们对分区的从属关系以及他们对分区的所有权关系,所有权关系一旦被分配到不会改变除非发生再均衡(比如有一个comsumer
              加入或者离开consumer group), consumer只会从对应的分区读取消息.
            2. Kafka限制consumer个数要**少于**分区个数, 每个消息只会被同一个consumer Group的一个消费者(非广播)
            3. Kafka的consumer group订阅同一个topic, 会尽可能地使得每一个consumer分配到相同数量的分区,不同consumer group同一个主题互相独立, 同一个消息会被不同的consumer group处理

        }
    }
    RabbitMQ（提供了4种：direct, topic ,Headers和fanout）{
        发送 {
            先声明一个队列, 这个队列会被创建或者已经被创建, 队列是基本的存储单元.有exchage和key决定消息队列存储到那个队列
            fanout：与key无关,会发送到所有和exchange绑定的队列 (比如订阅模式)
            direct：发送到bindingKey完全匹配的队列(比如路由模式)
            topic：路由key是含有".“的字符串, 会发送到含有”*", "#"进行模糊匹配的bindingKey对应的队列(比如topic模式, 也叫主题模式)
            headers：与key无关, 消息内容的headers属性(一个键值对)和绑定的键值对完全匹配时, 会发送此队列. 此方式性能低一般不用.
       }
       接收 {
            rabbitmq的队列是基本存储单元, 不在被分区或者分片, 对于我们已经创建了队列,消费端要指定从那个队列接收消息.
            work模式, 路由模式, topic模式: 当rabbitmq队列拥有多个consumer的时候, 每条消息只会发送给订阅列表里的一个consumer, 不会重复. 这种方式非常合适拓展, 而是专门为并发程序设计的
       }
    }
    RocketMQ（基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式）
    ActiveMQ（点对点(p2p)、广播（发布-订阅））
}

消息重试 {
    Kafka（不支持, 但是可以实现）{
        Kafka支持指定分区offset位置的回溯, 可以实现消息重试.
    }
    RabbitMQ（不支持,但是可以利用消息确认机制实现）{
        生产者 {
            其实RabbitMQ几乎可以保证99.99%发生成功, 但是偶尔也有失败,处理方式大概2种类: 1定时重发, 2记录日志人工处理, 如果是重要的消息可以发起系统预警
       }
       消费者 {
            当autoAck为false的时候，rabbitmq队列会分成两部分，一部分是等待投递给consumer的消息，一部分是已经投递但是没收到确认的消息。如果一直没有收到确认信号，并且consumer已经断开连接，
            rabbitmq会安排这个消息重新进入队列，投递给原来的消费者或者下一个消费者如果消费者消费3次都失败,可以根据业务情况进入死信队列
       }
    }
    RocketMQ（支持）{
        消息消费失败的大部分场景下, 立即重试99%都会失败, 所以rocketmq的策略是在消费失败时定时重试,每次时间间隔相同.即使跳过当前失败的消息，消费其他消息同样也会报错。
        这种情况可以sleep 30s，再消费下一条消息，减轻 Broker 重试消息的压力。
        生产者: (发送端的 send 方法本身支持内部重试) {
            1.最多重试3次
            2.如果发送失败, 则轮转到下一个broker
            3. 这个方法的总耗时不超过sendMsgTimeout设置的值，默认10s，超过时间不在重试
        }
        消费者: 消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer 消费消息失败通常可以分为以下两种情况 {
            1.由于消息本身的原因, 例如反序列化失败, 消息数据本身无法处理(比如充话费的时候,当前手机号不存在). 定时重试机制,比如超过10s后再重试
            2.由于依赖的下游应用服务器不可用, 例如db连接不可用, 外系统网络不可达.
        }
    }
    ActiveMQ（不支持）
}

并发度 {
    Kafka（高）{
        一个线程一个消费者, Kafka限制消费者的个数要<=分区数,如果要提高并行度, 可以在消费者中开启多线程, 或者增加consumer实例数量
    }
    RabbitMQ（极高）{
        本身是用Erlang语言写的，并发性能高。可在消费者中开启多线程，最常用的做法是一个channel对应一个消费者，每一个线程把持一个channel，多个线程复用connection的tcp连接，减少性能开销。
        当rabbitmq队列拥有多个消费者的时候，队列收到的消息将以轮询的分发方式发送给消费者。每条消息只会发送给订阅列表里的一个消费者，不会重复。
        这种方式非常适合扩展，而且是专门为并发程序设计的。如果某些消费者的任务比较繁重，那么可以设置basicQos限制信道上消费者能保持的最大未确认消息的数量，在达到上限时，
        rabbitmq不再向这个消费者发送任何消息
    }
    RocketMQ（高）{
        1.rocketmq限制消费者个数<=队列数,但是可以在消费者再开启多线程, 这一点和Kafka是一致的,提高并行度的方法相同. 修改消费并行度方法 {
            a.同一个ConsumerGroup下, 通过增加Consumer实例数量来提高并发度, 超过订阅队列数的Consumer实例无效.
            b.提高单个Consumer的消费并行线程, 通过修改参数consumeThreadMin, consumeThreadMax
        }
        2.同一个网络连接connection, 客户端多个线程连接可以同事发送请求,连接会被复用, 减少性能开销.
    }
    ActiveMQ（高）{
        单个ActiveMQ的接收和消费消息的速度在1万笔/秒（持久化 一般为1-2万， 非持久化 2 万以上），在生产环境中部署10个Activemq就能达到10万笔/秒以上的性能，
        部署越多的activemq broker 在MQ上latency也就越低，系统吞吐量也就越高
    }
}




